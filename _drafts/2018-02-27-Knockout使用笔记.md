#### ko.computed用prototype的形式来定义方法

参考文章：[Using prototype for KnockoutJS computed properties](https://stackoverflow.com/questions/14120507/using-prototype-for-knockoutjs-computed-properties)，主要分2步，定义并且注册即可

```javascript
ViewModel = function() {
  //注册prototype方法getFullName
   this.fullName = ko.computed(this.getFullName, this);
};

//定义prototype方法getFullName
ViewModel.prototype = {
   getFullName: function() {
      return this.firstName() + " " + this.lastName();
   }
};
```

#### 在ko.computed中使用setTimeout方法，导致循环执行原因

参考官方文档[How dependency tracking works](http://knockoutjs.com/documentation/computed-dependency-tracking.html)

```javascript
function ViewModel(){
    var self = this;
    //初始值
    self.countDownSeconds=ko.observable(0);
  
    self.testComputed = ko.computed(function () {
        //1. 这里调用countDownSeconds()方法，会把当前属性添加到computed依赖属性，这是导致循环调用的重要原因，当countDownSeconds发生变化的时候都会再次执行computed方法
       //解决方法：使用peek方法来调用即可，可以不让属性添加到computed依赖属性， self.countDownSeconds.peek();
        self.countDownSeconds();    
        
        setTimeout(function () {            
            self.countDownSeconds(self.countDownSeconds() + 1);
            console.log(self.countDownSeconds());
        }, 1000);        
 });
} 
```

#### call和apply理解

[apply/call传null或者undefined,指向的window对象](https://segmentfault.com/q/1010000005683545)

#### JS中利用setTimeout实现异步方法

参考文档[How can I create an Asynchronous function in Javascript?](https://stackoverflow.com/questions/9516900/how-can-i-create-an-asynchronous-function-in-javascript)

```javascript
function Test(){
    setTimeout(function () {
      console.log("异步方法1");
    });
    setTimeout(function () {
        console.log("异步方法2");
    });
    console.log("同步方法");
}

//调用test方法结果：
同步方法
异步方法1
异步方法2
```

