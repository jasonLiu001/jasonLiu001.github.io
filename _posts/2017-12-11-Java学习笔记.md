---
title: "Java"
date: 2017-12-11 14:07:00 +0800
---

#### Spring

Spring的体系结构图

![Spring体系结构](/assets/img/java-spring-arch1.png)

1. Spring容器使用DI管理组成应用程序的组件对象，这个组件对象就是Spring Beans，Spring容器根据配置的元数据去实例化对应的组件对象，这个元数据可以是XML配置，也可以是Java annotations，甚至于可以是Java代码
2. Bean就是Spring依赖注入中对应的类，每个Bean都是自己的生命周期，可以在生命周期的某个阶段添加构造函数
3. Spring框架比较重要的功能之一，实现依赖注入，通过依赖注入来实现解耦目的
4. [POJO](https://spring.io/understanding/POJO) : Plain Old Java Object
5. annotations也是Spring框架中比较重要实现依赖注入元数据查找的一种重要方式，另一种是XML形式
6. JavaBeans是一种特殊的类，这个类的特点参照
7. [@Bean注解使用](https://www.cnblogs.com/feiyu127/p/7700090.html)
8. Spring 的controller[请求参数](https://www.cnblogs.com/wxwBlog/p/6128882.html)

#### AOP编程思想

1. 面向切面编程思想--什么是AOP可以参考[Java的aop思想](https://blog.csdn.net/wangyongxia921/article/details/46272813)
2. [Spring的AOP实现](http://www.importnew.com/15420.html)，Spring借助了JDK proxy和CGlib两个技术实现了AOP
3. [.net下的aop实现](https://blog.csdn.net/niuyongjie/article/details/1288448)
4. AOP在实际中最常见的应用：
   1. 在请特定的资源之前，添加权限验证
   2. 在每个方法中添加日志记录，即使不继承特定的类，也可以调用对应的方法

#### IOC

把创建对象的任务交给框架

#### Spring、Spring MVC、Spring Boot的区别及各自解决的问题

1. 比较Spring、Spring MVC、Spring Boot非常好的文章，[Spring Boot vs. Spring MVC vs. Spring: How Do They Compare](https://dzone.com/articles/spring-boot-vs-spring-mvc-vs-spring-how-do-they-compare)
2. Spring Boot可以自动配置Servlet调度，自动配置数据源等。

> Spring Boot中使用的是Spring MVC，为什么看不到springmvc.xml这样的配置文件，这就是Spring Boot的魅力，auto-configure功能，Spring Boot只是快速开发包，是对Spring 资源的整合，方便开发，如果没有Spring Boot则需要我们做很多额外的工作，比如：数据库连接初始化，依赖包的引入，DI配置文件等



#### Spring Boot

1. SpringBoot配置文件：通过`spring.profiles.active`来指定当前需要的配置文件，[Profile-specific properties](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html#boot-features-external-config-profile-specific-properties)，在命令行中指定运行的配置文件：[Profiles](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-profiles.html#boot-features-profiles)，在命令行中通过传递`--spring.profiles.active=dev`

2. 各种starter的作用[Spring Boot：定制自己的starter](http://www.jianshu.com/p/85460c1d835a)

3. JdbcTemplate的默认FetchSize大小是100，可以通过setFetchSize方法来设置，能够提高性能，减少数据连接次数[make your java run faster](http://makejavafaster.blogspot.com/2015/06/jdbc-fetch-size-performance.html)或者[JDBC performance tuning with optimal fetch size](https://venkatsadasivam.com/2009/02/01/jdbc-performance-tuning-with-optimal-fetch-size/)

4. 写Statement和写Sql来查询数据的区别

   A statement is any text that the database engine recognizes as a valid command. As of SQL-92:

       An SQL-statement is a string of characters that conforms to the format and syntax rules specified in this international standard.

   A query is a statement that returns a recordset (possibly empty).

       How can I call a chunk of SQL code made by more than one statement where statements are separated by a semicolon (;)? Who already replied can edit his answer. Many thanks!
   A series of SQL statements sent to the server at once is called a batch.

5. [Statement和Preparedstatement的区别](https://stackoverflow.com/questions/3271249/difference-between-statement-and-preparedstatement)

6. throws clause用途：不捕获异常，传递异常

7. `Class path contains multiple SLF4J bindings`的错误解决[Maven SLF4J: Class path contains multiple SLF4J bindings](https://stackoverflow.com/questions/22896243/maven-slf4j-class-path-contains-multiple-slf4j-bindings/26283350)

8. Test应用程序[Spring Boot features Testing](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-testing.html) 

9. PreparedStatement的性能[PreparedStatement Performance](http://tutorials.jenkov.com/jdbc/preparedstatement.html#preparedstatement-performance)

10. PreparedStatement的查询需要next方法来读取数据

11. 关闭SpringBoot命令行进程

   参考链接地址：[How to shut down a Spring Boot command-line application](https://stackoverflow.com/questions/26329300/how-to-shut-down-a-spring-boot-command-line-application)

   ```java
   @Component
   public class OneTimeRunner implements CommandLineRunner {

       @Autowired
       private ConfigurableApplicationContext context;

       @Override
       public void run(String... args) throws Exception { 
          System.exit(SpringApplication.exit(context));
       }
   }
   ```

12. [Spring Boot使用Druid和监控配置](http://blog.csdn.net/xiaoyu411502/article/details/51392237)

13. [SpringBoot log4j2的RollingFile设置，每天生成新文件](https://www.boraji.com/log4j-2-rollingfileappender-example)

    设置的`filePattern`属性中的文件名和`Policies`属性中的值是对应的

    Here are sample date/time patterns for rolling of files base on date/time.

    | DATE/TIME Pattern            | Description                      | Intervale Attribute Example              |
    | ---------------------------- | -------------------------------- | ---------------------------------------- |
    | %d{yyyy-MM-dd-hh-mm}.log.zip | Roll the log files every minutes | If interval=2, rollovers will occur every 2nd minutes.E.g. - *2017-07-26-09-57.log.zip*, *2017-07-26-09-59.log.zip*, *2017-07-26-10-01.log.zip*, *2017-07-26-10-03.log.zip etc..* |
    | %d{yyyy-MM-dd-hh}.log.zip    | Roll the log files hourly        | If interval=4, rollovers will occur every 4 hours.E.g. - *2017-07-26-09.log.zip*, *2017-07-26-10.log.zip*, *2017-07-26-11.log.zip* *etc..* |
    | %d{yyyy-MM-dd}.log.zip       | Roll the log files daily         | If interval=1, rollovers will occur every day.E.g. - *2017-07-26.log.zip*, *2017-07-27.log.zip etc..*13. |

14. log4j2的[日志级别](https://logging.apache.org/log4j/2.x/manual/customloglevels.html)或者参照：[log4j2配置文件](http://www.cnblogs.com/hafiz/p/6170702.html)

    **程序会打印高于或等于所设置级别的日志，设置的日志等级越高，打印出来的日志就越少**。

    | Standard Level | intLevel            |
    | -------------- | ------------------- |
    | OFF            | 0                   |
    | FATAL          | 100                 |
    | ERROR          | 200                 |
    | WARN           | 300                 |
    | INFO           | 400                 |
    | DEBUG          | 500                 |
    | TRACE          | 600                 |
    | ALL            | `Integer.MAX_VALUE` |

15. [SpringBoot之CommandLineRunner接口和ApplicationRunner接口](http://blog.csdn.net/zknxx/article/details/52196427)

16. [CommandLineRunner和ApplicationRunner的区别和使用](https://dzone.com/articles/spring-boot-applicationrunner-and-commandlinerunne)，同时参考[Spring Boot CommandLineRunner and ApplicationRunner Example](https://www.concretepage.com/spring-boot/spring-boot-commandlinerunner-and-applicationrunner-example#commandlinerunner)

17. SpringBoot添加命令行参数：[config properties management](https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html)

18. 创建一个可运行的jar，[fully executable](https://docs.spring.io/spring-boot/docs/current/reference/html/deployment-install.html)并且部署到服务器

19. 自动退出SpringBoot控制台程序，[Spring Boot - Application exit code](http://www.logicbig.com/tutorials/spring-framework/spring-boot/app-exit-code/)

    ```java
    @SpringBootConfiguration
    public class ExampleExitCodeGenerator {

        @Bean
        MyBean myBean() {
            return new MyBean();
        }

        public static void main(String[] args) {
            ApplicationContext context = SpringApplication.run(ExampleExitCodeGenerator.class, args);

            MyBean myBean = context.getBean(MyBean.class);
            myBean.doSomething();

            int exitValue = SpringApplication.exit(context);
            System.exit(exitValue);
        }

        private static class MyBean implements ExitCodeGenerator {

            public void doSomething() {
                System.out.println("in doSomething()");
            }

            @Override
            public int getExitCode() {
                return 500;
            }
        }
    }
    ```

20. `@Component`注解的意思[@Component, @Service, @Repository and @Controller](https://www.concretepage.com/spring/spring-auto-detection-with-component-service-repository-and-controller-stereotype-annotation-example-using-componentscan-and-component-scan#component)

21. `whitelabel error page`错误解决

    Spring找不到创建的controller，需要添加如下注解，让Spring以下的包路径中查找需要初始化的组件，服务等

    ```shell
    # 在com.yiche.points.mobileweb和com.yiche.points.mobileservice包路径下查找controller并初始化
    @ComponentScan(basePackages = {"com.yiche.points.mobileweb", "com.yiche.points.mobileservice"})
    ```

22. 过滤器[添加自定义过滤器](http://www.baeldung.com/spring-security-custom-filter)，用户授权这类的操作，最好是在过滤器中操作，而不是添加拦截器

23. 拦截器[[Spring Boot 拦截器](http://blog.csdn.net/catoop/article/details/50501696)]和[Spring Boot 静态资源和拦截器处理](http://blog.csdn.net/gebitan505/article/details/70142025)

24. 拦截器实现[Springboot实现拦截器](https://www.cnblogs.com/jun-ma/p/5679459.html)

25. 拦截器和过滤器中如果添加`AuthenticationManager`的引用，有可能出现循环引用，最好的做法是创建拦截器的时候不再添加过滤器，只保持一个即可

    ```java
    The dependencies of some of the beans in the application context form a cycle:

       authenticateFilter (field private org.springframework.security.authentication.AuthenticationManager com.yiche.points.mobileweb.auth.AuthenticateFilter.authenticationManager)
    ┌─────┐
    |  authenticationManager defined in class path resource [org/springframework/boot/autoconfigure/security/AuthenticationManagerConfiguration.class]
    ↑     ↓
    |  webSecurityConfigurer
    ↑     ↓
    |  org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration$EnableWebMvcConfiguration
    ↑     ↓
    |  authenticateConfigurer (field com.yiche.points.mobileweb.auth.AuthenticateRequestInterceptor com.yiche.points.mobileweb.auth.AuthenticateConfigurer.authenticateRequestInterceptor)
    ↑     ↓
    |  getAuthenticateRequestInterceptor (field private org.springframework.security.authentication.AuthenticationManager com.yiche.points.mobileweb.auth.AuthenticateRequestInterceptor.authenticationManager)
    └─────┘
    ```

26. [用户登录授权](https://hellokoding.com/registration-and-login-example-with-spring-security-spring-boot-spring-data-jpa-hsql-jsp/)

27. Java Web使用token认证的两种形式[jwt-token-authentication-with-spring-boot](http://www.svlada.com/jwt-token-authentication-with-spring-boot/#jwt-authentication)

28. [@Bean注解作用](http://blog.csdn.net/javaloveiphone/article/details/52182899)：注册bean对象

29. [@Autowired属性为null原因分析](https://stackoverflow.com/questions/19896870/why-is-my-spring-autowired-field-null)

30. "Could not autowire. No beans of "，解决方法如下：

    ```java
        //1. 添加Autowired
    	@Autowired
        AuthenticateRequestInterceptor authenticateRequestInterceptor;

        //2. 添加Bean
        @Bean
        public AuthenticateRequestInterceptor getAuthenticateRequestInterceptor() {
            return new AuthenticateRequestInterceptor();
        }
    ```

31. 如何快速的定位被子类重写的父类方法

    1. 在idea中通过标记迅速定位到父类中的实现
    2. 定位到父类中的实现方法后，通过查找该方法的引用，找到该方法在父类的调用位置
    3. 下载该方法源码，一步一步分析实现

32. Spring中框架中方法链中的每个方法叫做End point，自己通过实现接口或者继承抽象类 对应的类中的 方法叫point cut。通过定义aop的实现，一定程度上减化了处理问题的难度，具体表现在很多抽象类的内部实现，大部分内容都是实现完成，我们只需要做的只是重新恰当的方法，业务流程甚至都可以直接沿用，不需要任何修改，因为很多类都已Null开头，表明这个方法也是很好的切入点，来实现自己的个性业务

33. Spring Boot中的异常处理，参考文档[[SpringBoot全局异常处理](http://blog.csdn.net/tianyaleixiaowu/article/details/70145251)]或者参考官方文档[Error Handling](https://docs.spring.io/spring-boot/docs/1.5.10.RELEASE/reference/htmlsingle/#boot-features-error-handling)

    1. 进入Controller前的全局异常处理
    2. Controller全局异常处理

34. [There is no default constructor错误](http://blog.csdn.net/m0_38021517/article/details/73647707)

35. spring.factories文件

36. [class<T>和 class<?>类型 有什么区别](http://www.cnblogs.com/skyislimit/p/5665853.html)

37. 查找类源码中的具体指定类，利用intellij中的search everywhere功能

38. 构造函数上添加@Autowired作用

39. 能够成功注入的几种方式

    1. 方法注入
    2. 属性注入
    3. 构造函数注入

40. [java中Servlet Cookie取不到值原因解决办法](http://www.jb51.net/article/116520.htm)在测试带Cookie的HTTP请求时发现，服务端用request.getHeader("cookie")可以去到值; 但是用request.getCookies()却不行

    ```java
    Cookie mycookies[] = request.getCookies();
    ```

    永远获取不到uid的值；（80端口号除外）

    原因：服务下发Cookie的时候带上了端口，而sessionId只会下方到不带端口的域名下：比如：127.0.0.1下有sessionId，在127.0.0.1:8080下则没有sessionId值

41. @SpringBootApplication注解包含了 @Configuration @EnableAutoConfiguration @ComponentScan这三个注解，里面有@EnableAutoConfiguration and @ComponentScan里包含的属性

42. [“repackage failed: Unable to find main class” with Maven on spring-boot project](https://stackoverflow.com/questions/42937577/unable-to-find-main-class-with-maven-on-spring-boot-project-in-eclipse) 

    提示项目缺少入口类，这是因为自己把maven的build插件放到了父pom中，而service项目是没有main入口的。解决：把父pom中的build插件节点去掉，只在有main入口的项目的pom中

43. ​


#### Spring Boot集成Spring Security中的PreAuthenticatedAuthenticationToken验证

参考文章，[jwt-token-authentication-with-spring-boot](http://www.svlada.com/jwt-token-authentication-with-spring-boot/#jwt-authentication)

在拦截器中实现自动授权登录，需要一个统一的授权入口页，必须首先访问这个页面以后，才能访问其他需要授权的资源

1. 添加对应的AuthenticationProvider

   ```java
   .....
   @Configuration
   @EnableWebSecurity
   public class WebSecurityConfigurer extends WebSecurityConfigurerAdapter {
       .....
       
       @Autowired
       public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception 	{
          //添加AuthenticationProvider
           auth.authenticationProvider(authenticationProvider());
       }
       //设置AuthenticationProvider为PreAuthenticatedAuthenticationProvider
       private AuthenticationProvider authenticationProvider() {
           PreAuthenticatedAuthenticationProvider authProvider = new PreAuthenticatedAuthenticationProvider();
           authProvider.setPreAuthenticatedUserDetailsService(new PreAuthenticatedGrantedAuthoritiesUserDetailsService());
           return authProvider;
       }
   }
   ```

2. 在拦截器或者过滤器中添加授权信息

   ```java
   .....
   public class AuthenticateRequestInterceptor extends HandlerInterceptorAdapter {
       .....
     
       @Autowired
       private AuthenticationManager authenticationManager;

       @Override
       public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o) throws Exception {
           //TODO:解析Cookies
           String token = "11634";

           //保存APP授权后的token值
           PreAuthenticatedAuthenticationToken authToken = new PreAuthenticatedAuthenticationToken(token, "N/A");
           Set<GrantedAuthority> grantedAuthorities = new HashSet<>();
           authToken.setDetails(grantedAuthorities);

           authenticationManager.authenticate(authToken);
           SecurityContextHolder.getContext().setAuthentication(authToken);

           // 只有返回true才会继续向下执行，返回false取消当前请求
           return true;
       }
   }
   ```

3. HttpSecurity中的addFilterBefore方法里面有一个comparator对象，这个对象里存储了所有的filter顺序，下面是FilterComparator中的构造函数的一部分

   ```java
   FilterComparator() {
   		int order = 100;
   		put(ChannelProcessingFilter.class, order);
   		order += STEP;
   		put(ConcurrentSessionFilter.class, order);
   		order += STEP;
   		put(WebAsyncManagerIntegrationFilter.class, order);
   		order += STEP;
   		put(SecurityContextPersistenceFilter.class, order);
   		order += STEP;
   		put(HeaderWriterFilter.class, order);
   		order += STEP;
   		put(CorsFilter.class, order);
   		order += STEP;
   		put(CsrfFilter.class, order);
     		......
           ......
   }
   ```

4. [Invalid CSRF Token 'null' was found on the request parameter '_csrf' or header 'X-CSRF-TOKEN' 错误解决](http://blog.csdn.net/u012373815/article/details/55047285)

5. [Custom token based authentication of REST services with Spring-Security](https://www.future-processing.pl/blog/exploring-spring-boot-and-spring-security-custom-token-based-authentication-of-rest-services-with-spring-security-and-pinch-of-spring-java-configuration-and-spring-integration-testing/)



#### Idea中开发Spring Boot时热部署启用步骤

1. 添加maven依赖

   ```xml
   <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-devtools</artifactId>
          <optional>true</optional>
   </dependency>
   ```

2. POM文件添加插件

   ```xml
   <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
        <configuration>
        	<!--fork :  如果没有该项配置devtools不会起作用，即应用不会restart -->
         	<fork>true</fork>
         <addResources>true</addResources><!--支持静态文件热部署-->
         </configuration>
   </plugin>
   ```

3. 打开Idea的设置，定位到compiler节点，勾选`make project automatically`选项

4. `Shift+Crtl+Alt+/`打开maintenance界面选择Registry后，勾选`compiler.automake.allow.when.app.running`选项后，点击Close关闭

5. 重启Idea，设置完成，热部署功能启用完毕


#### Maven创建可执行Jar的多种方式

1. 通过Maven创建可执行的Jar[How to Create an Executable JAR with Maven](http://www.baeldung.com/executable-jar-with-maven)，该文章里包含多种创建Jar的方式

2. 通过Spring Boot创建可执行Jar[Creating an executable jar](https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-first-application.html#getting-started-first-application-executable-jar)或者[Spring Boot non-web application example](https://www.mkyong.com/spring-boot/spring-boot-non-web-application-example/)

3. 以服务的形式运行SpringBoot:[Spring Boot Application as a Service](http://www.baeldung.com/spring-boot-app-as-a-service)

4. Maven Scope的作用范围

   依赖范围控制哪些依赖在哪些classpath 中可用，哪些依赖包含在一个应用中。让我们详细看一下每一种范围：

   **compile （编译范围）**

   compile是默认的范围；如果没有提供一个范围，那该依赖的范围就是编译范围。编译范围依赖在所有的classpath 中可用，同时它们也会被打包。

   **provided （已提供范围）**

   provided 依赖只有在当JDK 或者一个容器已提供该依赖之后才使用。例如， 如果你开发了一个web 应用，你可能在编译 classpath 中需要可用的Servlet API 来编译一个servlet，但是你不会想要在打包好的WAR 中包含这个Servlet API；这个Servlet API JAR 由你的应用服务器或者servlet 容器提供。已提供范围的依赖在编译classpath （不是运行时）可用。它们不是传递性的，也不会被打包。

   **runtime （运行时范围）**

   runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC
   驱动实现。

   **test （测试范围）**

   test范围依赖 在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。

   **system （系统范围）**

   system范围依赖与provided 类似，但是你必须显式的提供一个对于本地系统中JAR 文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven 也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个 systemPath 元素。注意该范围是不推荐使用的（你应该一直尽量去从公共或定制的 Maven 仓库中引用依赖）。

5. unmanaged dependencies的创建方式，参考文章[Creating a Maven Project Local Repository](http://nicholaspaulsmith.com/creating-a-maven-project-local-repository/)或者[Adding Unmanaged Dependencies to a Maven Project](https://devcenter.heroku.com/articles/local-maven-dependencies#pick-groupid-artifactid-and-version-parameters)，这两篇文章的功能是一样的，都是讲本地项目作为一个依赖，并且不需要安装到本地的Maven库

6. 添加jar到maven工程，[3 ways to add local jar to maven project](http://roufid.com/3-ways-to-add-local-jar-to-maven-project/#3-_creating_a_different_local_maven_repository)

7. ​

#### SpringBoot定时任务

1. [Task Execution and Scheduling](https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/scheduling.html)
2. [How to Schedule Tasks with Spring Boot](https://www.callicoder.com/spring-boot-task-scheduling-with-scheduled-annotation/)
3. [Task Execution and Scheduling](https://docs.spring.io/spring/docs/3.0.x/spring-framework-reference/html/scheduling.html#scheduling-task-namespace)
4. [Scheduling Tasks](https://spring.io/guides/gs/scheduling-tasks/)
5. 中文文章[SpringBoot定时任务](http://blog.csdn.net/loongshawn/article/details/50663393)
   + 单任务
   + 多任务
   + 动态任务
6. 关于任务线程池执行的文章[Rules of a ThreadPoolExecutor pool size](http://www.bigsoft.co.uk/blog/index.php/2009/11/27/rules-of-a-threadpoolexecutor-pool-size)
7. SpringBoot使用log4j2日志记录，[How to use Log4j 2 with Spring Boot](https://www.callicoder.com/spring-boot-log4j-2-example/)
8. [Spring Boot注解含义](http://www.everycoding.com/coding/372.html)
9. [理解Spring Boot注解](http://benweizhu.github.io/blog/2015/06/10/spring-boot-starter-1/)

##### MySql

1. [分表partition table](https://docs.oracle.com/cd/B28359_01/server.111/b32024/partition.htm)

2. Java数据类型和MySql数据类型的转换对应，参考链接[ Java, JDBC and MySQL Types](https://dev.mysql.com/doc/connector-j/5.1/en/connector-j-reference-type-conversions.html)

   | These MySQL Data Types                   | Can always be converted to these Java types |
   | ---------------------------------------- | ---------------------------------------- |
   | `CHAR, VARCHAR, BLOB, TEXT, ENUM, and SET` | `java.lang.String, java.io.InputStream, java.io.Reader,                java.sql.Blob, java.sql.Clob` |
   | `FLOAT, REAL, DOUBLE PRECISION, NUMERIC, DECIMAL, TINYINT,                SMALLINT, MEDIUMINT, INTEGER, BIGINT` | `java.lang.String, java.lang.Short, java.lang.Integer,                java.lang.Long, java.lang.Double,                java.math.BigDecimal` |
   | `DATE, TIME, DATETIME, TIMESTAMP`        | `java.lang.String, java.sql.Date, java.sql.Timestamp` |

3. 查询昨天的当前时刻

   ```mssql
   SELECT NOW() - INTERVAL 1 DAY
   ```

4. MySql中insert时已存在对应记录则更新

   参考文章链接：[https://chartio.com/resources/tutorials/how-to-insert-if-row-does-not-exist-upsert-in-mysql/](https://chartio.com/resources/tutorials/how-to-insert-if-row-does-not-exist-upsert-in-mysql/)

   ```mssql
   -- 两种方式
   -- 使用replace,replace会先执行delete再执行insert

   -- 使用INSERT ... ON DUPLICATE KEY UPDATE，这个不会执行delete操作，能够保证记录完整性
   ```

5. ​

#### Spring JDBC

Spring框架中的jdbcTemplate不需要手动的关闭connection，框架自己会处理，参考文章：[Introduction to Spring Framework JDBC](https://docs.spring.io/spring/docs/3.0.x/spring-framework-reference/html/jdbc.html)

**Table 12.1. Spring JDBC - who does what?**

| Action                                   | Spring | You  |
| ---------------------------------------- | ------ | ---- |
| Define connection parameters.            |        | X    |
| Open the connection.                     | X      |      |
| Specify the SQL statement.               |        | X    |
| Declare parameters and provide parameter values |        | X    |
| Prepare and execute the statement.       | X      |      |
| Set up the loop to iterate through the results (ifany). | X      |      |
| Do the work for each iteration.          |        | X    |
| Process any exception.                   | X      |      |
| Handle transactions.                     | X      |      |
| Close the connection, statement and resultset. | X      |      |

上面的这张表说明了，我们需要关注的几个地方，其他的框架都会自己处理，无需关心

1. PreparedStatement的setDate保存到数据库时，只有日期部分没有时间解决

   ```java
   //通过这个保存后的日期为：2017-12-15 00:00:00
   ps.setDate(2, new java.sql.Date(new java.util.Date().getTime()));

   //通过setTimestamp方法可以保留时间部分：2017-12-15 05:03:05
   ps.setTimestamp(2, new java.sql.Timestamp(new java.util.Date().getTime()));
   ```

2. ​

#### IDEA自定义代码折叠

1. [Custom code folding regions in IntelliJ IDEA 11.1](https://blog.jetbrains.com/idea/2012/03/custom-code-folding-regions-in-intellij-idea-111/)
2. ​

#### Spring Boot Console 程序 简单示例

```java
@SpringBootApplication
//自动侦测所有的注解类
@ComponentScan(basePackages = {"com.yiche.coin", "com.yiche.points"})
public class CoinTaskApplication {
    public static void main(String[] args) {
        //初始化程序上下文，这个时候Spring Boot框架会自动侦测在classpath路径下所有使用了注解的类
       //这些注解包括 @Component, @Service, @Repository and @Controller 
      // The spring stereotype @Component is parent stereotype. The other stereotypes i.e @Service, @Repository and @Controller are the specialization of @Component annotation
        ApplicationContext appContext = SpringApplication.run(CoinTaskApplication.class, args);

        //获取指定的Bean对象
        TradeRepairTool repairBean = appContext.getBean(TradeRepairTool.class);
        repairBean.launched();

        //释放资源，退出程序
        int exitValue = SpringApplication.exit(appContext);
        System.exit(exitValue);
    }
}
```

#### Spring Boot MVC

1. [spring boot mvc的快速简介](http://blog.csdn.net/sky786905664/article/details/52092415)

#### Thymeleaf

1. layout母版布局页

   添加templates/layout/default.html模板页

   ```html
   <html xmlns:th="http://www.thymeleaf.org"
         xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout">
     <title>Layout 母版页</title>
     <div class="content">
           <div layout:fragment="page_content"></div>
   </div>
   </html>
   ```

2. 添加templates/home/index.html子页面，并使用布局页

   ```html
   <html xmlns:th="http://www.thymeleaf.org"
         xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
         layout:decorator="layout/default">
     <div layout:fragment="page_content">
       我是母版页
   </div>
   </html>
   ```

3. [spring-boot thymeleaf对没有结束符的HTML5标签解析出错解决办法](http://blog.csdn.net/ngl272/article/details/70215435)

4. Thymeleaf获取url参数的形式，参照[Themyleaf基础对象和web参数访问方式](http://blog.csdn.net/mygzs/article/details/52668099)，可以通过内置对象获取web环境中特定的属性实现值的读取

   1. url形如：http://localhost:1105/index?productId=5

      获取其中productId的值有以下2种方式：

      ```html
      <!--通过web对象的#httpServletRequest.getParameter()方法获取-->
      <input th:value="${#httpServletRequest.getParameter('productId')}"/>

      <!--通过param属性获取-->
      <input  th:if="${param.productId!=null && param.productId[0]}"/>
      ```

   2. url的参数包含在path中，形如：http://localhost:8081/mobile/home/product/100

      获取path中100这个值有以下2种方式：

      ```html
      <!--通过#vars基础对象获取-->
      <input th:value="${#vars.get('productId')}"/>

      <!--通过web对象的#httpServletRequest.getAttribute()方法获取-->
      <input th:value="${#httpServletRequest.get('productId')}"/>
      ```

5. 从模板中获取controller中的数据，参考[Thymeleaf+SpringMVC，如何从模板中获取数据](https://www.cnblogs.com/jiangchao226/p/5938152.html)，有几种方式，通过addAttribute方法或者其他方式...，下面显示，如何在视图中使用attribute中的属性

   ```html
   <tr th:each="message : ${messages}">
       <td th:text="${message.id}">1</td>
       <td><a href="#" th:text="${message.title}">Title ...</a></td>
       <td th:text="${message.text}">Text ...</td>
   </tr>
   ```

6. Java @RequestBody是对象时，使用ajax提交时，需要对data进行JSON.stringify(data)后提交，如果@RequestBody是String时，直接把data当做字符提交，参数名称省略

7. 解决ios下点击事件闪烁问题，[ios下点击闪烁](http://blog.csdn.net/muyufenghua/article/details/44461695)

