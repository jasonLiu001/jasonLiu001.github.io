---
title: "Java"
date: 2017-12-11 14:07:00 +0800
---

#### Spring

Spring的体系结构图

![Spring体系结构](/assets/img/java-spring-arch1.png)

1. Spring容器使用DI管理组成应用程序的组件对象，这个组件对象就是Spring Beans，Spring容器根据配置的元数据去实例化对应的组件对象，这个元数据可以是XML配置，也可以是Java annotations，甚至于可以是Java代码
2. Bean就是Spring依赖注入中对应的类，每个Bean都是自己的生命周期，可以在生命周期的某个阶段添加构造函数
3. Spring框架比较重要的功能之一，实现依赖注入，通过依赖注入来实现解耦目的
4. [POJO](https://spring.io/understanding/POJO) : Plain Old Java Object
5. annotations也是Spring框架中比较重要实现依赖注入元数据查找的一种重要方式，另一种是XML形式
6. JavaBeans是一种特殊的类，这个类的特点参照

#### Idea中开发Spring Boot时热部署启用步骤

1. 添加maven依赖

   ```xml
   <dependency>
          <groupId>org.springframework.boot</groupId>
          <artifactId>spring-boot-devtools</artifactId>
          <optional>true</optional>
   </dependency>
   ```

2. POM文件添加插件

   ```xml
   <plugin>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-maven-plugin</artifactId>
        <configuration>
        	<!--fork :  如果没有该项配置devtools不会起作用，即应用不会restart -->
         	<fork>true</fork>
         <addResources>true</addResources><!--支持静态文件热部署-->
         </configuration>
   </plugin>
   ```

3. 打开Idea的设置，定位到compiler节点，勾选`make project automatically`选项

4. `Shift+Crtl+Alt+/`打开maintenance界面选择Registry后，勾选`compiler.automake.allow.when.app.running`选项后，点击Close关闭

5. 重启Idea，设置完成，热部署功能启用完毕


#### Maven创建可执行Jar的多种方式

1. 通过Maven创建可执行的Jar[How to Create an Executable JAR with Maven](http://www.baeldung.com/executable-jar-with-maven)，该文章里包含多种创建Jar的方式

2. 通过Spring Boot创建可执行Jar[Creating an executable jar](https://docs.spring.io/spring-boot/docs/current/reference/html/getting-started-first-application.html#getting-started-first-application-executable-jar)或者[Spring Boot non-web application example](https://www.mkyong.com/spring-boot/spring-boot-non-web-application-example/)

3. 以服务的形式运行SpringBoot:[Spring Boot Application as a Service](http://www.baeldung.com/spring-boot-app-as-a-service)

4. Maven Scope的作用范围

   依赖范围控制哪些依赖在哪些classpath 中可用，哪些依赖包含在一个应用中。让我们详细看一下每一种范围：

   **compile （编译范围）**

   compile是默认的范围；如果没有提供一个范围，那该依赖的范围就是编译范围。编译范围依赖在所有的classpath 中可用，同时它们也会被打包。

   **provided （已提供范围）**

   provided 依赖只有在当JDK 或者一个容器已提供该依赖之后才使用。例如， 如果你开发了一个web 应用，你可能在编译 classpath 中需要可用的Servlet API 来编译一个servlet，但是你不会想要在打包好的WAR 中包含这个Servlet API；这个Servlet API JAR 由你的应用服务器或者servlet 容器提供。已提供范围的依赖在编译classpath （不是运行时）可用。它们不是传递性的，也不会被打包。

   **runtime （运行时范围）**

   runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC
   驱动实现。

   **test （测试范围）**

   test范围依赖 在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。

   **system （系统范围）**

   system范围依赖与provided 类似，但是你必须显式的提供一个对于本地系统中JAR 文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven 也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个 systemPath 元素。注意该范围是不推荐使用的（你应该一直尽量去从公共或定制的 Maven 仓库中引用依赖）。

5. unmanaged dependencies的创建方式，参考文章[Creating a Maven Project Local Repository](http://nicholaspaulsmith.com/creating-a-maven-project-local-repository/)或者[Adding Unmanaged Dependencies to a Maven Project](https://devcenter.heroku.com/articles/local-maven-dependencies#pick-groupid-artifactid-and-version-parameters)，这两篇文章的功能是一样的，都是讲本地项目作为一个依赖，并且不需要安装到本地的Maven库

#### SpringBoot定时任务

1. [Task Execution and Scheduling](https://docs.spring.io/spring/docs/3.2.x/spring-framework-reference/html/scheduling.html)
2. [How to Schedule Tasks with Spring Boot](https://www.callicoder.com/spring-boot-task-scheduling-with-scheduled-annotation/)
3. [Task Execution and Scheduling](https://docs.spring.io/spring/docs/3.0.x/spring-framework-reference/html/scheduling.html#scheduling-task-namespace)
4. [Scheduling Tasks](https://spring.io/guides/gs/scheduling-tasks/)
5. 中文文章[SpringBoot定时任务](http://blog.csdn.net/loongshawn/article/details/50663393)
   + 单任务
   + 多任务
   + 动态任务
6. 关于任务线程池执行的文章[Rules of a ThreadPoolExecutor pool size](http://www.bigsoft.co.uk/blog/index.php/2009/11/27/rules-of-a-threadpoolexecutor-pool-size)

